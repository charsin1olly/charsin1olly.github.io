{"meta":{"title":"Charsin's co_oding life","subtitle":"","description":"hello","author":"John Doe","url":"http://charsin1olly.github.io","root":"/"},"pages":[],"posts":[{"title":"Stimulus是一個酷東西！","slug":"20221127 Stimulus","date":"2022-11-27T12:25:51.000Z","updated":"2022-11-27T12:29:31.398Z","comments":true,"path":"2022/11/27/20221127 Stimulus/","link":"","permalink":"http://charsin1olly.github.io/2022/11/27/20221127%20Stimulus/","excerpt":"","text":"什麼是Stimulus?它可以做什麼？ Stimulus是一種輕量JS框架，主要在HTML上操作，data就是他開始貼標籤的地方。 它可以簡化JS抓DOM元素的繁雜過程。 主要核心是Controllers、action、target，做成類似rails 路徑名稱那樣的標籤，包在div、button…任何的&lt;&gt;裡面。 前置作業：安裝stimulus套件在專案資料夾輸入rails查看可以裝什麼框架找到想裝的框架再輸入（同樣適用於圖片上的其他框架） 1rails webpacker:install:stimulus 這樣webpacker就會在javascript的資料夾幫我們做好stimulus需要的資料夾app&#x2F;javascript&#x2F;controllers 這是JS版controller的家，裡面有一個index檔案是使套件可以正常使用的程式碼 123456import &#123; Application &#125; from &quot;stimulus&quot;import &#123; definitionsFromContext &#125; from &quot;stimulus/webpack-helpers&quot;const application = Application.start()const context = require.context(&quot;controllers&quot;, true, /_controller\\.js$/)application.load(definitionsFromContext(context)) app&#x2F;javascript&#x2F;controllers&#x2F;hello_controller.js 是一個範例檔，主要用法就是用import接收erb檔設定的controller傳來的訊息，並用export回傳接下來要做的動作。 123456789import &#x27;controllers&#x27; export default class extends Controller &#123; static targets = [ &quot;icon&quot; ] connect() &#123; console.log(&quot;hello&quot;) &#125; &#125; 在export default class extends Controller{}裡可以放任何controller所需要用到的function 常用 123connect()：連接上時的觸發事件，可以用來測試是否連接initialize():可使用於設定初始狀態static targets =[]：抓設定data-xxx-target的關鍵字（使用陣列放多個target） stimulus運作stimulus核心三兄弟的運作，我自己理解到的運作模式大概是這樣： Controller1data-controller=&quot;favorite-btn&quot; 這塊地歸我管囉（插一個favorite-btn的旗子，建立favorite-btn_controller辦事處） 用於設定我們要建立controller的控制範圍及名稱，範圍可大可小，小至一個按鈕，大可以到一整個html，但盡量讓控制範圍小一點比較方便維護。 註：檔名為 XXX_controller.js (這個XXX要跟後來設定的data-controller名稱一樣，不然會抓不到) Action：1data-action=&quot;click-&gt;favorite-btn#toggle&quot; 我幫你看看favorite-btn有沒有發生什麼事件。發生點擊事件(click)的時候我會叫你的toggle部門出來做事的！ 相當於JavaScript的addEventListener，但不限定只有click之類的預設事件，可以設定範圍，例如update-quantity@document-&gt;order-amount#updateQuantity就代表在document的範圍內監聽update-quantity事件出現，就到order-amount進行updateQuantity的動作。 Target：欸那個新來的，現在開始你的名字叫做icon，我叫你做什麼就做什麼1data-favorite-btn-target=&quot;icon&quot; 相當於JavaScript的document.querySelector(“”)、或是其他抓DOM元素系列的指令。搭配在export default class extends Controller裡的設定：static targets = [ &quot;icon&quot; ]就是抓到icon這個Target，並可以使用iconTarget進行操作（例如：iconTarget.textContent=&quot;&quot; 等）。 結論最近的Ruby on rails課程提到該如何將JavaScript寫進Rails專案，提到了Stimulus，它不但可以用類似於rails裡面Controller的操作方式決定接下來要做什麼，還可以方便的取用DOM元素，使用AJAX概念紀錄當前操作結果節省網路傳輸，並且集中的controller資料夾能使檔案變得更好管理。 參考連結：官方手冊、Github","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://charsin1olly.github.io/tags/JavaScript/"}]},{"title":"find 與 find_by 是差在哪裡啦！","slug":"20221123 find&find_by","date":"2022-11-23T04:08:33.000Z","updated":"2022-11-23T04:32:43.093Z","comments":true,"path":"2022/11/23/20221123 find&find_by/","link":"","permalink":"http://charsin1olly.github.io/2022/11/23/20221123%20find&find_by/","excerpt":"","text":"在rails裡撈資料一下用find、一下用find_by，該用哪個才好呢？先來比較一下它們兩個的不同吧！ 現在我們建立了一個WishList的Model，建立1個wishlist項目，在rails console裡是這樣的現在看看全部的WishList，現在id編號只有排到7 現在我們來尋找id編號為999的實體資料， 用find尋找實體用find尋找@wish_list=WishList.find(params[:id])，會直接顯示ActiveRecord::RecordNotFound換成大家熟悉的畫面是這樣 用find_by尋找實體如果是換成用find_by@wish_list=WishList.find_by(id: params[:id])，則會顯示這是nil換成網頁版 其實find_by有一個兄弟，叫做find_by!它擁有find_by的外表以及find的功能，找不到這筆資料的時候會直接顯示ActiveRecord::RecordNotFound 該用find還是find_by?總結上面提到內容，find跟find_by的不同就是嚴格程度的不同（沒有這個id就不給你過vs沒有這個id也是可以通過）。如果我們不需要顯示畫面到那筆不存在的資料，那就使用find（例如：這個id所屬的這個頁面不存在，直接讓rails報錯再直接轉去404頁面顯示這個頁面不存在）；如果需要比對這筆資料存不存在，會需要利用這個空集合作計算或判斷的話，就使用find_by(例如：會員登入所輸入的帳號是否註冊過？如果他是一個nil就可以被塞到實體變數而不是報錯) 結論就是：選擇find或find_by就是取決於自己要獲得的結果是錯誤訊息還是一個nil值。","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"}]},{"title":"如何將rails頁面連結到404.html","slug":"20221118 如何將rails頁面連結到404.html","date":"2022-11-18T14:32:00.000Z","updated":"2022-11-23T04:10:31.035Z","comments":true,"path":"2022/11/18/20221118 如何將rails頁面連結到404.html/","link":"","permalink":"http://charsin1olly.github.io/2022/11/18/20221118%20%E5%A6%82%E4%BD%95%E5%B0%87rails%E9%A0%81%E9%9D%A2%E9%80%A3%E7%B5%90%E5%88%B0404.html/","excerpt":"","text":"站內連結聯到找不到的頁面時，會連結到錯誤畫面（因為我用find方法，找不到會直接顯示錯誤訊息） 這時我們就可以用rescue_from捕捉意外，捕捉到什麼呢？ActiveRecord::RecordNotFound 這個錯誤訊息，並且呼叫”record_not_found”（其實可以叫做not_found，只是為了避免以後又有其他not_found系列的方法要再修正比較麻煩，命名準確一點方便維護） 12ActionController::Baserescue_from ActiveRecord::RecordNotFound ,with: :record_not_found 既然呼叫了，我們還是要再建立一個叫做record_not_found的方法：這個方法要做什麼呢？就是要渲染我們想要的頁面（為什麼不是跳轉？第一個是我們沒有給404檔案裝路徑，第二是因為我們要留在原本找不到的那個網址）渲染別的檔案我們使用render file，要找到不是在view資料夾裡面的404.html檔案的話可以用”#{Rails.root}”，意思是我要在這個Rails專案的目錄下尋找ＸＸＸ，後面接上路徑就是到某個資料夾尋找某個檔案 1render file: &quot;#&#123;Rails.root&#125;/public/404.html&quot; 渲染成功，打開網路狀態會看到這樣的結果 網路狀態200（正常的找到你的”找不到”頁面），我們也希望網路的狀態被改成404，在render file後面設定一個status： 404 ，就會得到這樣的畫面 獲得真正的404頁面！完整程式碼： 1234567ActionController::Baserescue_from ActiveRecord::RecordNotFound ,with: :record_not_foundprivatedef record_not_found render file: &quot;#&#123;Rails.root&#125;/public/404.html&quot;,layout: false ,status: 400end","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-11-16T12:01:53.156Z","updated":"2022-11-16T12:01:53.157Z","comments":true,"path":"2022/11/16/hello-world/","link":"","permalink":"http://charsin1olly.github.io/2022/11/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"var、let、const的差別","slug":"20221116 var&let&const","date":"2022-11-16T03:47:36.000Z","updated":"2022-11-16T12:09:14.298Z","comments":true,"path":"2022/11/16/20221116 var&let&const/","link":"","permalink":"http://charsin1olly.github.io/2022/11/16/20221116%20var&let&const/","excerpt":"","text":"1.重複宣告123var a = 1var a = 2console.log(a) // 印出2 var可以重複宣告，並且後來宣告的a會覆蓋前面的a。 123let a = 1let a = 2console.log(a) //錯誤 let不能重複宣告，這樣執行console.log(a)會跳出錯誤訊息：Identifier ‘a’ has already been declared告訴你a這個名字用過了。 123const a = 1const a = 2console.log(a) //錯誤 const和let一樣不能重複宣告，執行會跳出和let一樣的錯誤訊息 ：Identifier ‘a’ has already been declared。 2.重新賦值1234var a = 1var a = 2a=3console.log(a) //印出 3 var除了可以重複宣告以外，也可以直接用全域變數直接重新賦值這樣console.log(a)印出來的結果會是3。 123let a = 1a = 2console.log(a) //印出2 上面提到過let不能重複宣告，但它可以使用全域變數直接賦值 123const a = 1a = 2console.log(a) //錯誤 雖然const跟let一樣不能重複宣告，但const更加嚴格，全域變數也不能重值賦值，會跳出錯誤訊息Assignment to constant variable. 但是const也不是完全不能改變，假如const是一個陣列，我們可以藉由指定元素來變更內容 ： 123const a=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]a[0]=&quot;X&quot;console.log(a) //印出[ &#x27;X&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ] 3.作用的scopevar的作用範圍是function scope，也就是作用在function區域裡面都可以取用的變數，出了function就拿不到了 1234function hi()&#123; var a=1&#125;console.log(a) //印出 ReferenceError: a is not defined 如果不是放在function內的話還是可以在外部取用 12345age = 10if(age&gt;5)&#123; var a = &quot;in block!&quot;;&#125;console.log(a); //印出in block! let的作用範圍都是block scope，在{}的範圍以外就無法取用了 12345age = 10if(age&gt;5)&#123; let a = &quot;in block!&quot;;&#125;console.log(a); //印出 a is not defined 補充：迴圈也是{}應用的一種（這裡的 a is not defined是指console.log(“out:”+a)的a），通常使用let。為什麼不用const呢？因為a++等同於 a&#x3D;a+1，我們前面已經讓a是一個常數(const)了，不能明目張膽的改變它的內容，執行會顯示錯誤訊息Assignment to constant variable. 12345for(let a=0 ; a&lt;5 ; a++)&#123; console.log(a)&#125;console.log(&quot;out:&quot;+a) //印出 a is not defined const也是block scope，a無法在外部被取用。 12345age = 10if(age&gt;5)&#123; const a = &quot;in block!&quot;;&#125;console.log(a); //印出 a is not defined 4.TDZ 暫時性死區12console.log(a) //印出 undefinedvar a = 1 var有變數提昇的特性，如果就以執行順序來看的話，明明還沒宣告var a &#x3D; 1 怎麼console.log會說a是undefined呢？JS執行順序為由上往下，步驟分成兩步，第一步先註冊名稱，第二步為賦值，變數提昇有點類似預告，在第一步的時候掃描到var a，告訴系統：「今天有一個a客人會來喔！」，進入第二步賦值由於還沒輪到把1賦予a就被印出來了，所以結果是undefined。 1234567console.log(a)let a = 1console.log(a)const a = 1以上console.log(a)都會印出 ReferenceError: Cannot access &#x27;a&#x27; before initialization let、const則是有一個TDZ，類似一個防雷馬賽克，在第一步的時候TDZ就蓋在let（const）上面，系統就不知道有a客人，進行到第二步就會像a去客人去系統報到，系統卻說：「你沒有預約訂位喔」的樣子。 這樣的設計可以使流程更加嚴謹，使程式邏輯更加通順、增加可讀性。（就像是：我的點的菜還沒炒好卻可以包空氣帶走？這不太對吧？） 5.污染window在瀏覽器的主控台上宣告 var a&#x3D;1 , let b &#x3D;2 , const c &#x3D;3在window裡面只會有a會被建立出來， 【結論】宣告的嚴謹程度 const &gt; let &gt; var盡量使用const，可以視情況適當改用let，非到萬不得已再使用var。","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"}]}],"categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://charsin1olly.github.io/tags/JavaScript/"}]}