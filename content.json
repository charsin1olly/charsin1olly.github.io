{"meta":{"title":"Charsin's co_oding life","subtitle":"","description":"hello","author":"John Doe","url":"http://charsin1olly.github.io","root":"/"},"pages":[],"posts":[{"title":"find 與 find_by 是差在哪裡啦！","slug":"20221123 find&find_by","date":"2022-11-23T04:08:33.000Z","updated":"2022-11-23T04:18:24.503Z","comments":true,"path":"2022/11/23/20221123 find&find_by/","link":"","permalink":"http://charsin1olly.github.io/2022/11/23/20221123%20find&find_by/","excerpt":"","text":"在rails裡撈資料一下用find、一下用find_by，該用哪個才好呢？先來比較一下它們兩個的不同吧！ 現在我們建立了一個WishList的Model，建立1個wishlist項目，在rails console裡是這樣的現在看看全部的WishList，現在id編號只有排到7 其實就是…嚴格程度不同現在我們來尋找id編號為999的實體資料， 用find尋找實體用find尋找@wish_list=WishList.find(params[:id])，會直接顯示ActiveRecord::RecordNotFound換成大家熟悉的畫面是這樣 用find_by尋找實體如果是換成用find_by@wish_list=WishList.find_by(id: params[:id])，則會顯示這是nil換成網頁版 其實find_by有一個兄弟，叫做find_by!它擁有find_by的外表以及find的功能，找不到這筆資料的時候會直接顯示ActiveRecord::RecordNotFound 該用find還是find_by?如果我們不需要顯示畫面到那筆不存在的資料，那就使用find（例如：這個id所屬的這個頁面不存在，直接讓rails報錯再直接轉去404頁面顯示這個頁面不存在）；如果需要比對這筆資料存不存在，會需要利用這個空集合作計算或判斷的話，就使用find_by(例如：會員登入所輸入的帳號是否註冊過？如果他是一個nill就可以被塞到實體變數而不是報錯) 結論就是：選擇find或find_by就是取決於自己要獲得的結果是錯誤訊息還是一個nil值。","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"}]},{"title":"如何將rails頁面連結到404.html","slug":"20221118 如何將rails頁面連結到404.html","date":"2022-11-18T14:32:00.000Z","updated":"2022-11-23T04:10:31.035Z","comments":true,"path":"2022/11/18/20221118 如何將rails頁面連結到404.html/","link":"","permalink":"http://charsin1olly.github.io/2022/11/18/20221118%20%E5%A6%82%E4%BD%95%E5%B0%87rails%E9%A0%81%E9%9D%A2%E9%80%A3%E7%B5%90%E5%88%B0404.html/","excerpt":"","text":"站內連結聯到找不到的頁面時，會連結到錯誤畫面（因為我用find方法，找不到會直接顯示錯誤訊息） 這時我們就可以用rescue_from捕捉意外，捕捉到什麼呢？ActiveRecord::RecordNotFound 這個錯誤訊息，並且呼叫”record_not_found”（其實可以叫做not_found，只是為了避免以後又有其他not_found系列的方法要再修正比較麻煩，命名準確一點方便維護） 12ActionController::Baserescue_from ActiveRecord::RecordNotFound ,with: :record_not_found 既然呼叫了，我們還是要再建立一個叫做record_not_found的方法：這個方法要做什麼呢？就是要渲染我們想要的頁面（為什麼不是跳轉？第一個是我們沒有給404檔案裝路徑，第二是因為我們要留在原本找不到的那個網址）渲染別的檔案我們使用render file，要找到不是在view資料夾裡面的404.html檔案的話可以用”#{Rails.root}”，意思是我要在這個Rails專案的目錄下尋找ＸＸＸ，後面接上路徑就是到某個資料夾尋找某個檔案 1render file: &quot;#&#123;Rails.root&#125;/public/404.html&quot; 渲染成功，打開網路狀態會看到這樣的結果 網路狀態200（正常的找到你的”找不到”頁面），我們也希望網路的狀態被改成404，在render file後面設定一個status： 404 ，就會得到這樣的畫面 獲得真正的404頁面！完整程式碼： 1234567ActionController::Baserescue_from ActiveRecord::RecordNotFound ,with: :record_not_foundprivatedef record_not_found render file: &quot;#&#123;Rails.root&#125;/public/404.html&quot;,layout: false ,status: 400end","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-11-16T12:01:53.156Z","updated":"2022-11-16T12:01:53.157Z","comments":true,"path":"2022/11/16/hello-world/","link":"","permalink":"http://charsin1olly.github.io/2022/11/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"var、let、const的差別","slug":"20221116 var&let&const","date":"2022-11-16T03:47:36.000Z","updated":"2022-11-16T12:09:14.298Z","comments":true,"path":"2022/11/16/20221116 var&let&const/","link":"","permalink":"http://charsin1olly.github.io/2022/11/16/20221116%20var&let&const/","excerpt":"","text":"1.重複宣告123var a = 1var a = 2console.log(a) // 印出2 var可以重複宣告，並且後來宣告的a會覆蓋前面的a。 123let a = 1let a = 2console.log(a) //錯誤 let不能重複宣告，這樣執行console.log(a)會跳出錯誤訊息：Identifier ‘a’ has already been declared告訴你a這個名字用過了。 123const a = 1const a = 2console.log(a) //錯誤 const和let一樣不能重複宣告，執行會跳出和let一樣的錯誤訊息 ：Identifier ‘a’ has already been declared。 2.重新賦值1234var a = 1var a = 2a=3console.log(a) //印出 3 var除了可以重複宣告以外，也可以直接用全域變數直接重新賦值這樣console.log(a)印出來的結果會是3。 123let a = 1a = 2console.log(a) //印出2 上面提到過let不能重複宣告，但它可以使用全域變數直接賦值 123const a = 1a = 2console.log(a) //錯誤 雖然const跟let一樣不能重複宣告，但const更加嚴格，全域變數也不能重值賦值，會跳出錯誤訊息Assignment to constant variable. 但是const也不是完全不能改變，假如const是一個陣列，我們可以藉由指定元素來變更內容 ： 123const a=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]a[0]=&quot;X&quot;console.log(a) //印出[ &#x27;X&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ] 3.作用的scopevar的作用範圍是function scope，也就是作用在function區域裡面都可以取用的變數，出了function就拿不到了 1234function hi()&#123; var a=1&#125;console.log(a) //印出 ReferenceError: a is not defined 如果不是放在function內的話還是可以在外部取用 12345age = 10if(age&gt;5)&#123; var a = &quot;in block!&quot;;&#125;console.log(a); //印出in block! let的作用範圍都是block scope，在{}的範圍以外就無法取用了 12345age = 10if(age&gt;5)&#123; let a = &quot;in block!&quot;;&#125;console.log(a); //印出 a is not defined 補充：迴圈也是{}應用的一種（這裡的 a is not defined是指console.log(“out:”+a)的a），通常使用let。為什麼不用const呢？因為a++等同於 a&#x3D;a+1，我們前面已經讓a是一個常數(const)了，不能明目張膽的改變它的內容，執行會顯示錯誤訊息Assignment to constant variable. 12345for(let a=0 ; a&lt;5 ; a++)&#123; console.log(a)&#125;console.log(&quot;out:&quot;+a) //印出 a is not defined const也是block scope，a無法在外部被取用。 12345age = 10if(age&gt;5)&#123; const a = &quot;in block!&quot;;&#125;console.log(a); //印出 a is not defined 4.TDZ 暫時性死區12console.log(a) //印出 undefinedvar a = 1 var有變數提昇的特性，如果就以執行順序來看的話，明明還沒宣告var a &#x3D; 1 怎麼console.log會說a是undefined呢？JS執行順序為由上往下，步驟分成兩步，第一步先註冊名稱，第二步為賦值，變數提昇有點類似預告，在第一步的時候掃描到var a，告訴系統：「今天有一個a客人會來喔！」，進入第二步賦值由於還沒輪到把1賦予a就被印出來了，所以結果是undefined。 1234567console.log(a)let a = 1console.log(a)const a = 1以上console.log(a)都會印出 ReferenceError: Cannot access &#x27;a&#x27; before initialization let、const則是有一個TDZ，類似一個防雷馬賽克，在第一步的時候TDZ就蓋在let（const）上面，系統就不知道有a客人，進行到第二步就會像a去客人去系統報到，系統卻說：「你沒有預約訂位喔」的樣子。 這樣的設計可以使流程更加嚴謹，使程式邏輯更加通順、增加可讀性。（就像是：我的點的菜還沒炒好卻可以包空氣帶走？這不太對吧？） 5.污染window在瀏覽器的主控台上宣告 var a&#x3D;1 , let b &#x3D;2 , const c &#x3D;3在window裡面只會有a會被建立出來， 【結論】宣告的嚴謹程度 const &gt; let &gt; var盡量使用const，可以視情況適當改用let，非到萬不得已再使用var。","categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"}]}],"categories":[],"tags":[{"name":"學習筆記","slug":"學習筆記","permalink":"http://charsin1olly.github.io/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://charsin1olly.github.io/tags/Ruby-on-Rails/"}]}